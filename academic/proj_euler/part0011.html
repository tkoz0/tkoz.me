<!DOCTYPE html>
<html>
<head>
    <title>Project Euler</title>
    <link rel="stylesheet" type="text/css" href="/mathstyles.css" />
    <link rel="stylesheet" type="text/css" href="/prismjs/proj_euler.css" />
    <script type="text/javascript">
        window.MathJax = { tex: { macros: {
            red: ['{\\color{red}#1}',1],
            lcm: '\\text{lcm}'
        }}};
    </script>
    <script type="text/javascript" src="/mathscripts.js"></script>
    <script type="text/javascript" src="/prismjs/proj_euler.js"></script>
</head>
<body>
<div id="root">

<h1>Project Euler</h1>

<p>Written solutions for problems 11-20.</p>

<p>Prev: <a href="part0001.html">problems 1-10</a></p>

<p>Next: (coming soon)</p>

<!-- generate table of contents using h2-h6 tags -->
<div id="toc"></div>

<h2>Problem 11</h2>

<p>
    <b>Problem:</b> Find the greastest product of 4 adjacent numbers along a
    horizontal, vertical, or diagonal line in the following grid:
</p>

<pre style="text-align:center;">
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
</pre>

<p>
    This problem is small enough to solve by brute force. We can use the sliding
    window technique described in problem 8, but I'll avoid it here. One thing
    to remember is there are 2 diagonal directions. Here is the code:
</p>

<pre><code class="language-python">
grid = [
[ 8, 2,22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8],
[49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0],
[81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65],
[52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91],
[22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
[24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50],
[32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
[67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21],
[24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
[21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95],
[78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92],
[16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57],
[86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58],
[19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40],
[ 4,52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66],
[88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69],
[ 4,42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36],
[20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16],
[20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54],
[ 1,70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48]]

def product(nums):
    ret = 1
    for n in nums:
        ret *= n
    return ret

L = 4 # product length
R,C = len(grid),len(grid[0]) # grid size
largest = 0
sol_rc = (-1,-1)
sol_nums = []
sol_dir = ''
for r in range(len(grid)):
    for c in range(len(grid[0])):
        if r + L &lt;= R: # vertical
            nums = [grid[r+i][c] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down'
        if c + L &lt;= C: # horizontal
            nums = [grid[r][c+i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'right'
        if r + L &lt;= R and c + L &lt;= C: # diagonal 1
            nums = [grid[r+i][c+i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down-right'
        if r + L &lt;= R and c &gt;= L-1: # diagonal 2
            nums = [grid[r+i][c-i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down-left'
print(largest)
print(f'start at {sol_rc} going {sol_dir} multiply {sol_nums}')
</code></pre>

<details><summary>Answer:</summary>70600674<br />
Product is \(87\cdot97\cdot94\cdot89\) (starting in the 16th row and 4th column,
going along the up-right diagonal)</details>

<h2>Problem 12</h2>

<p>
    <b>Problem:</b> Find the smallest triangle number with over 500 divisors.
</p>

<p>
    This could be done by brute force once we have a way to calculate how many
    prime factors a number has, but we'll use a faster method. First we will
    look at 2 ways to count divisors of \(n\). We could have a loop for all
    numbers \(1,2,\ldots,n\), but if \(p\leq\lfloor\sqrt{n}\rfloor\) then
    \(n=pq\) with \(q\geq\lfloor\sqrt{n}\rfloor\) so for each divisor below the
    square root, there is a corresponding divisor. This allows us to loop over
    \(1,2,\ldots,\lfloor\sqrt{n}\rfloor\) which is much faster. The only special
    case to handle is for perfect squares.
</p>

<p>
    The other method we'll look at is by factoring the number. If we have a
    prime factorization \(n=p_1^{a_1}p_2^{a_2}\ldots\), then we can choose
    exponents for each prime from 0 to \(a_i\) to form a divisor. This tells us
    that the number of divisors is \((a_1+1)(a_2+1)\ldots\). This may be just as
    slow as the other method, such as when \(n\) is a semiprime, but it helps
    significantly when \(n\) has some small prime factors, so this is the method
    we will use. This divisor counting function is similar to the solution for
    problem 3.
</p>

<p>
    Now, we will look at a method of generating triangle nummbers. Every
    triangle number is \(\sum_{i=1}^ni=n(n+1)/2\) for some \(n\). So we can
    start a loop at \(n=1\) going up. Now we compute divisors of \(n(n+1)/2\).
    There is a more efficient way to do this by observing that \(n\) and \(n+1\)
    are coprime. One of those 2 will be even. If \(n\) is even, then \(n/2\)
    and \(n+1\) are coprime. If \(n+1\) is even, then \(n\) and \((n+1)/2\) are
    coprime. Now if \(\gcd(p,q)=1\), then \(D(pq)=D(p)D(q)\) where \(D(x)\) is
    the number of divisors of \(x\), because \(p\) and \(q\) do not share prime
    factors. It is much faster this way because we can find the number of
    divisors by factoring 2 much smaller numbers instead of 1 big number.
</p>

<pre><code class="language-python">
def divcount(n):
    factors = 1
    while n % 2 == 0: # divide out 2s
        factors += 1
        n //= 2
    d = 3
    while d*d &lt;= n: # find multiplicity of prime factors
        multiplicity = 0
        while n % d == 0:
            multiplicity += 1
            n //= d
        factors *= multiplicity+1
        d += 2
    if n != 1: # last prime factor
        factors *= 2
    return factors

D = 500
n = 1
while True: # try n(n+1)/2
    if n % 2 == 0: # n/2,n+1
        d1 = divcount(n//2)
        d2 = divcount(n+1)
    else: # n,(n+1)/2
        d1 = divcount(n)
        d2 = divcount((n+1)//2)
    if d1*d2 > D:
        print(n*(n+1)//2)
        print(f'{d1*d2} divisors, n = {n}')
        break
    n += 1
</code></pre>

<details><summary>Answer:</summary>76576500<br />
The factorization is \(2^2\cdot3^2\cdot5^3\cdot7\cdot11\cdot13\cdot17\) and
it has \(3\cdot3\cdot4\cdot2\cdot2\cdot2\cdot2=576\) divisors</details>

<h2>Problem 13</h2>

<h2>Problem 14</h2>

<h2>Problem 15</h2>

<h2>Problem 16</h2>

<h2>Problem 17</h2>

<h2>Problem 18</h2>

<h2>Problem 19</h2>

<h2>Problem 20</h2>

</div>
</body>
</html>
