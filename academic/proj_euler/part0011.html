<!DOCTYPE html>
<html>
<head>
    <title>Project Euler 11-20</title>
    <link rel="stylesheet" type="text/css" href="/mathstyles.css" />
    <link rel="stylesheet" type="text/css" href="/prismjs/proj_euler.css" />
    <script type="text/javascript">
        window.MathJax = { tex: { macros: {
            red: ['{\\color{red}#1}',1],
            lcm: '\\text{lcm}'
        }}};
    </script>
    <script type="text/javascript" src="/mathscripts.js"></script>
    <script type="text/javascript" src="/prismjs/proj_euler.js"></script>
</head>
<body>
<div id="root">

<h1>Project Euler 11-20</h1>

<span>
    <a href="index.html">index</a> |
    <a href="part0001.html">prev (1-10)</a> |
    <a href="part0021.html">next (21-30)</a>
</span>

<!-- generate table of contents using h2-h6 tags -->
<div id="toc"></div>

<h2>Problem 11</h2>

<p>
    <b>Problem:</b> Find the greastest product of 4 adjacent numbers along a
    horizontal, vertical, or diagonal line in the following grid:
</p>

<pre style="text-align:center;">
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
</pre>

<p>
    This problem is small enough to solve by brute force. We can use the sliding
    window technique described in problem 8, but I'll avoid it here. One thing
    to remember is there are 2 diagonal directions. Here is the code:
</p>

<pre><code class="language-python">
grid = [
[ 8, 2,22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8],
[49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0],
[81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65],
[52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91],
[22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
[24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50],
[32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
[67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21],
[24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
[21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95],
[78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92],
[16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57],
[86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58],
[19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40],
[ 4,52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66],
[88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69],
[ 4,42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36],
[20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16],
[20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54],
[ 1,70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48]]

def product(nums):
    ret = 1
    for n in nums:
        ret *= n
    return ret

L = 4 # product length
R,C = len(grid),len(grid[0]) # grid size
largest = 0
sol_rc = (-1,-1)
sol_nums = []
sol_dir = ''
for r in range(len(grid)):
    for c in range(len(grid[0])):
        if r + L &lt;= R: # vertical
            nums = [grid[r+i][c] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down'
        if c + L &lt;= C: # horizontal
            nums = [grid[r][c+i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'right'
        if r + L &lt;= R and c + L &lt;= C: # diagonal 1
            nums = [grid[r+i][c+i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down-right'
        if r + L &lt;= R and c &gt;= L-1: # diagonal 2
            nums = [grid[r+i][c-i] for i in range(L)]
            prod = product(nums)
            if prod &gt; largest:
                largest = prod
                sol_rc = (r,c)
                sol_nums = nums
                sol_dir = 'down-left'
print(largest)
print(f'start at {sol_rc} going {sol_dir} multiply {sol_nums}')
</code></pre>

<details><summary>Answer:</summary>70600674<br />
Product is \(87\cdot97\cdot94\cdot89\) (starting in the 16th row and 4th column,
going along the up-right diagonal)</details>

<h2>Problem 12</h2>

<p>
    <b>Problem:</b> Find the smallest triangle number with over 500 divisors.
    The \(n\)th triangle number is \(1+2+\ldots+n\).
</p>

<p>
    This could be done by brute force once we have a way to calculate how many
    prime factors a number has, but we'll use a faster method. First we will
    look at 2 ways to count divisors of \(n\). We could have a loop for all
    numbers \(1,2,\ldots,n\), but if \(p\leq\lfloor\sqrt{n}\rfloor\) then
    \(n=pq\) with \(q\geq\lfloor\sqrt{n}\rfloor\) so for each divisor below the
    square root, there is a corresponding divisor. This allows us to loop over
    \(1,2,\ldots,\lfloor\sqrt{n}\rfloor\) which is much faster. The only special
    case to handle is for perfect squares.
</p>

<p>
    The other method we'll look at is by factoring the number. If we have a
    prime factorization \(n=p_1^{a_1}p_2^{a_2}\ldots\), then we can choose
    exponents for each prime from 0 to \(a_i\) to form a divisor. This tells us
    that the number of divisors is \((a_1+1)(a_2+1)\ldots\). This may be just as
    slow as the other method, such as when \(n\) is a semiprime, but it helps
    significantly when \(n\) has some small prime factors, so this is the method
    we will use. This divisor counting function is similar to the solution for
    problem 3.
</p>

<p>
    Now, we will look at a method of generating triangle nummbers. Every
    triangle number is \(\sum_{i=1}^ni=n(n+1)/2\) for some \(n\). So we can
    start a loop at \(n=1\) going up. Now we compute divisors of \(n(n+1)/2\).
    There is a more efficient way to do this by observing that \(n\) and \(n+1\)
    are coprime. One of those 2 will be even. If \(n\) is even, then \(n/2\)
    and \(n+1\) are coprime. If \(n+1\) is even, then \(n\) and \((n+1)/2\) are
    coprime. Now if \(\gcd(p,q)=1\), then \(D(pq)=D(p)D(q)\) where \(D(x)\) is
    the number of divisors of \(x\), because \(p\) and \(q\) do not share prime
    factors. It is much faster this way because we can find the number of
    divisors by factoring 2 much smaller numbers instead of 1 big number.
</p>

<pre><code class="language-python">
def divcount(n):
    factors = 1
    while n % 2 == 0: # divide out 2s
        factors += 1
        n //= 2
    d = 3
    while d*d &lt;= n: # find multiplicity of prime factors
        multiplicity = 0
        while n % d == 0:
            multiplicity += 1
            n //= d
        factors *= multiplicity+1
        d += 2
    if n != 1: # last prime factor
        factors *= 2
    return factors

D = 500
n = 1
while True: # try n(n+1)/2
    if n % 2 == 0: # n/2,n+1
        d1 = divcount(n//2)
        d2 = divcount(n+1)
    else: # n,(n+1)/2
        d1 = divcount(n)
        d2 = divcount((n+1)//2)
    if d1*d2 > D:
        print(n*(n+1)//2)
        print(f'{d1*d2} divisors, n = {n}')
        break
    n += 1
</code></pre>

<details><summary>Answer:</summary>76576500<br />
The factorization is \(2^2\cdot3^2\cdot5^3\cdot7\cdot11\cdot13\cdot17\) and
it has \(3\cdot3\cdot4\cdot2\cdot2\cdot2\cdot2=576\) divisors</details>

<h2>Problem 13</h2>

<p>
    <b>Problem:</b> Find the first 10 digits of the sum of these 100 numbers
    (50 digits each):
</p>

<pre style="text-align:center;">
37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690
</pre>

<p>
    In Python, we can just sum the numbers easily since large integers are
    supported:
</p>

<pre><code class="language-python">
s = sum([
37107287533902102798797998220837590246510135740250,
46376937677490009712648124896970078050417018260538,
74324986199524741059474233309513058123726617309629,
91942213363574161572522430563301811072406154908250,
23067588207539346171171980310421047513778063246676,
89261670696623633820136378418383684178734361726757,
28112879812849979408065481931592621691275889832738,
44274228917432520321923589422876796487670272189318,
47451445736001306439091167216856844588711603153276,
70386486105843025439939619828917593665686757934951,
62176457141856560629502157223196586755079324193331,
64906352462741904929101432445813822663347944758178,
92575867718337217661963751590579239728245598838407,
58203565325359399008402633568948830189458628227828,
80181199384826282014278194139940567587151170094390,
35398664372827112653829987240784473053190104293586,
86515506006295864861532075273371959191420517255829,
71693888707715466499115593487603532921714970056938,
54370070576826684624621495650076471787294438377604,
53282654108756828443191190634694037855217779295145,
36123272525000296071075082563815656710885258350721,
45876576172410976447339110607218265236877223636045,
17423706905851860660448207621209813287860733969412,
81142660418086830619328460811191061556940512689692,
51934325451728388641918047049293215058642563049483,
62467221648435076201727918039944693004732956340691,
15732444386908125794514089057706229429197107928209,
55037687525678773091862540744969844508330393682126,
18336384825330154686196124348767681297534375946515,
80386287592878490201521685554828717201219257766954,
78182833757993103614740356856449095527097864797581,
16726320100436897842553539920931837441497806860984,
48403098129077791799088218795327364475675590848030,
87086987551392711854517078544161852424320693150332,
59959406895756536782107074926966537676326235447210,
69793950679652694742597709739166693763042633987085,
41052684708299085211399427365734116182760315001271,
65378607361501080857009149939512557028198746004375,
35829035317434717326932123578154982629742552737307,
94953759765105305946966067683156574377167401875275,
88902802571733229619176668713819931811048770190271,
25267680276078003013678680992525463401061632866526,
36270218540497705585629946580636237993140746255962,
24074486908231174977792365466257246923322810917141,
91430288197103288597806669760892938638285025333403,
34413065578016127815921815005561868836468420090470,
23053081172816430487623791969842487255036638784583,
11487696932154902810424020138335124462181441773470,
63783299490636259666498587618221225225512486764533,
67720186971698544312419572409913959008952310058822,
95548255300263520781532296796249481641953868218774,
76085327132285723110424803456124867697064507995236,
37774242535411291684276865538926205024910326572967,
23701913275725675285653248258265463092207058596522,
29798860272258331913126375147341994889534765745501,
18495701454879288984856827726077713721403798879715,
38298203783031473527721580348144513491373226651381,
34829543829199918180278916522431027392251122869539,
40957953066405232632538044100059654939159879593635,
29746152185502371307642255121183693803580388584903,
41698116222072977186158236678424689157993532961922,
62467957194401269043877107275048102390895523597457,
23189706772547915061505504953922979530901129967519,
86188088225875314529584099251203829009407770775672,
11306739708304724483816533873502340845647058077308,
82959174767140363198008187129011875491310547126581,
97623331044818386269515456334926366572897563400500,
42846280183517070527831839425882145521227251250327,
55121603546981200581762165212827652751691296897789,
32238195734329339946437501907836945765883352399886,
75506164965184775180738168837861091527357929701337,
62177842752192623401942399639168044983993173312731,
32924185707147349566916674687634660915035914677504,
99518671430235219628894890102423325116913619626622,
73267460800591547471830798392868535206946944540724,
76841822524674417161514036427982273348055556214818,
97142617910342598647204516893989422179826088076852,
87783646182799346313767754307809363333018982642090,
10848802521674670883215120185883543223812876952786,
71329612474782464538636993009049310363619763878039,
62184073572399794223406235393808339651327408011116,
66627891981488087797941876876144230030984490851411,
60661826293682836764744779239180335110989069790714,
85786944089552990653640447425576083659976645795096,
66024396409905389607120198219976047599490197230297,
64913982680032973156037120041377903785566085089252,
16730939319872750275468906903707539413042652315011,
94809377245048795150954100921645863754710598436791,
78639167021187492431995700641917969777599028300699,
15368713711936614952811305876380278410754449733078,
40789923115535562561142322423255033685442488917353,
44889911501440648020369068063960672322193204149535,
41503128880339536053299340368006977710650566631954,
81234880673210146739058568557934581403627822703280,
82616570773948327592232845941706525094512325230608,
22918802058777319719839450180888072429661980811197,
77158542502016545090413245809786882778948721859617,
72107838435069186155435662884062257473692284509516,
20849603980134001723930671666823555245252804609722,
53503534226472524250874054075591789781264330331690
])
print(str(s)[:10])
</code></pre>

<p>
    If we want to challenge ourselves a little more or do this in a language
    without large integer support, we can perform the add and carry operations:
</p>

<pre><code class="language-python">
nums = [
'37107287533902102798797998220837590246510135740250',
'46376937677490009712648124896970078050417018260538',
'74324986199524741059474233309513058123726617309629',
'91942213363574161572522430563301811072406154908250',
'23067588207539346171171980310421047513778063246676',
'89261670696623633820136378418383684178734361726757',
'28112879812849979408065481931592621691275889832738',
'44274228917432520321923589422876796487670272189318',
'47451445736001306439091167216856844588711603153276',
'70386486105843025439939619828917593665686757934951',
'62176457141856560629502157223196586755079324193331',
'64906352462741904929101432445813822663347944758178',
'92575867718337217661963751590579239728245598838407',
'58203565325359399008402633568948830189458628227828',
'80181199384826282014278194139940567587151170094390',
'35398664372827112653829987240784473053190104293586',
'86515506006295864861532075273371959191420517255829',
'71693888707715466499115593487603532921714970056938',
'54370070576826684624621495650076471787294438377604',
'53282654108756828443191190634694037855217779295145',
'36123272525000296071075082563815656710885258350721',
'45876576172410976447339110607218265236877223636045',
'17423706905851860660448207621209813287860733969412',
'81142660418086830619328460811191061556940512689692',
'51934325451728388641918047049293215058642563049483',
'62467221648435076201727918039944693004732956340691',
'15732444386908125794514089057706229429197107928209',
'55037687525678773091862540744969844508330393682126',
'18336384825330154686196124348767681297534375946515',
'80386287592878490201521685554828717201219257766954',
'78182833757993103614740356856449095527097864797581',
'16726320100436897842553539920931837441497806860984',
'48403098129077791799088218795327364475675590848030',
'87086987551392711854517078544161852424320693150332',
'59959406895756536782107074926966537676326235447210',
'69793950679652694742597709739166693763042633987085',
'41052684708299085211399427365734116182760315001271',
'65378607361501080857009149939512557028198746004375',
'35829035317434717326932123578154982629742552737307',
'94953759765105305946966067683156574377167401875275',
'88902802571733229619176668713819931811048770190271',
'25267680276078003013678680992525463401061632866526',
'36270218540497705585629946580636237993140746255962',
'24074486908231174977792365466257246923322810917141',
'91430288197103288597806669760892938638285025333403',
'34413065578016127815921815005561868836468420090470',
'23053081172816430487623791969842487255036638784583',
'11487696932154902810424020138335124462181441773470',
'63783299490636259666498587618221225225512486764533',
'67720186971698544312419572409913959008952310058822',
'95548255300263520781532296796249481641953868218774',
'76085327132285723110424803456124867697064507995236',
'37774242535411291684276865538926205024910326572967',
'23701913275725675285653248258265463092207058596522',
'29798860272258331913126375147341994889534765745501',
'18495701454879288984856827726077713721403798879715',
'38298203783031473527721580348144513491373226651381',
'34829543829199918180278916522431027392251122869539',
'40957953066405232632538044100059654939159879593635',
'29746152185502371307642255121183693803580388584903',
'41698116222072977186158236678424689157993532961922',
'62467957194401269043877107275048102390895523597457',
'23189706772547915061505504953922979530901129967519',
'86188088225875314529584099251203829009407770775672',
'11306739708304724483816533873502340845647058077308',
'82959174767140363198008187129011875491310547126581',
'97623331044818386269515456334926366572897563400500',
'42846280183517070527831839425882145521227251250327',
'55121603546981200581762165212827652751691296897789',
'32238195734329339946437501907836945765883352399886',
'75506164965184775180738168837861091527357929701337',
'62177842752192623401942399639168044983993173312731',
'32924185707147349566916674687634660915035914677504',
'99518671430235219628894890102423325116913619626622',
'73267460800591547471830798392868535206946944540724',
'76841822524674417161514036427982273348055556214818',
'97142617910342598647204516893989422179826088076852',
'87783646182799346313767754307809363333018982642090',
'10848802521674670883215120185883543223812876952786',
'71329612474782464538636993009049310363619763878039',
'62184073572399794223406235393808339651327408011116',
'66627891981488087797941876876144230030984490851411',
'60661826293682836764744779239180335110989069790714',
'85786944089552990653640447425576083659976645795096',
'66024396409905389607120198219976047599490197230297',
'64913982680032973156037120041377903785566085089252',
'16730939319872750275468906903707539413042652315011',
'94809377245048795150954100921645863754710598436791',
'78639167021187492431995700641917969777599028300699',
'15368713711936614952811305876380278410754449733078',
'40789923115535562561142322423255033685442488917353',
'44889911501440648020369068063960672322193204149535',
'41503128880339536053299340368006977710650566631954',
'81234880673210146739058568557934581403627822703280',
'82616570773948327592232845941706525094512325230608',
'22918802058777319719839450180888072429661980811197',
'77158542502016545090413245809786882778948721859617',
'72107838435069186155435662884062257473692284509516',
'20849603980134001723930671666823555245252804609722',
'53503534226472524250874054075591789781264330331690'
]
total = [0]*50 # digits starting from most significant
for num_str in nums:
    carry = 0
    i = len(total)-1 # i,j are which index to add
    j = len(num_str)-1
    while i &gt;= 0 and j &gt;= 0: # add num_str to the total
        sum_ = total[i] + int(num_str[j]) + carry
        total[i] = sum_ % 10
        carry = sum_ // 10
        i -= 1
        j -= 1
    while i &gt;= 0 and carry &gt; 0: # propogate carry
        sum_ = total[i] + carry
        total[i] = sum_ % 10
        carry = sum_ // 10
        i -= 1
    if carry &gt; 0 and i &lt; 0: # need to extend by a digit
        total.insert(0,carry)
print(''.join(map(str,total[:10])))
</code></pre>

<details><summary>Answer:</summary>5537376230</details>

<h2>Problem 14</h2>

<p>
    <b>Problem:</b> Find the starting number under 1000000 produces the longest
    Collatz sequence chain. Given a starting number \(n\), we generate the
    Collatz sequence by updating it as shown below, terminating at 1 (it is
    conjectured that every sequence ends at 1, but not proven).
</p>

\[n\rightarrow\begin{cases}
n/2 & \text{if $n$ is even}\\
3n+1 & \text{if $n$ is odd}\\
\end{cases}\]

<p>
    The simplest way to solve this is by iterating Collatz sequences for all
    numbers below 1000000. We can speed this up by caching sequence lengths so
    when a larger starting number reaches a number we already had, we do not
    have to repeat the work.
</p>

<pre><code class="language-python">
L = 1000000

cache_len = [0]*L
cache_max = [0]*L # track max in sequence (extra, unneeded)
cache_len[1] = 1
cache_max[1] = 1
for n_start in range(2,L):
    len_ = 0
    max_ = 0
    n = n_start
    while n >= n_start:
        len_ += 1
        max_ = max(max_,n)
        if n % 2 == 0:
            n //= 2
        else:
            n = 3*n + 1
    # use cache to finish
    cache_len[n_start] = len_ + cache_len[n]
    cache_max[n_start] = max(max_,cache_max[n])

# number with longest chain
max_len = max(cache_len)
max_len_nums = [i for i in range(L) if cache_len[i] == max_len]

# number with highest peak value in its chain
max_max = max(cache_max)
max_max_nums = [i for i in range(L) if cache_max[i] == max_max]

print(f'highest number iterated {max_max}')
print(f'reached from starting number(s) {max_max_nums}')
print(f'maximum chain length {max_len}')
for n in max_len_nums:
    print(f'starting number {n} reaches max of {cache_max[n]}')
    print(n)
</code></pre>

<p>
    Note: the longest chain found has length 525. The highest number ever
    reached during chain iteration is 56991483520, which is too big for 32 bit
    integers.
</p>

<details><summary>Answer:</summary>837799</details>

<h2>Problem 15</h2>

<p>
    <b>Problem:</b> Starting from the top left corner of a \(20\times20\) grid,
    find how many possible paths there are to the bottom right corner by moving
    only right and down. For example, in a \(2\times2\) grid, the answer is 6,
    as shown in the image below borrowed from the Project Euler website.
</p>

<img src="0015.png" class="img_center" />

<p>
    One way is to recursively find all paths, but that is too slow for this
    problem. We could use dynamic programming to solve this, because a solution
    for the number of paths starting at a position depends only on that of
    positions right and down from it. Along the bottom and right edge, there is
    only 1 path. Everything else in the middle can be filled in by adding the
    solution for the points directly adjacent on the right and down.
</p>

<pre><code class="language-python">
R = 20
C = 20

# dp[r][c] is the solution for a r*c grid
dp = [[0]*(C+1) for _ in range(R+1)]

# 1 path along the edges
for r in range(R+1):
    dp[r][0] = 1
for c in range(C+1):
    dp[0][c] = 1

# fill in the rest of the sub problems
for r in range(1,R+1):
    for c in range(1,C+1):
        dp[r][c] = dp[r-1][c] + dp[r][c-1]

# the solution is dp[20][20]
print(dp[R][C])
</code></pre>

<p>
    Another way is to notice how each path will contain 20 steps right and 20
    steps down, for 40 steps total. If we choose which of these 40 positions
    are right steps, and make the rest down steps, there are \({40}\choose{20}\)
    ways to do this. This can be calculated by hand but is tedious.
</p>

<p>
    Note: the solution does not fit in a 32 bit integer.
</p>

<details><summary>Answer:</summary>137846528820</details>

<h2>Problem 16</h2>

<p>
    <b>Problem:</b> Find the sum of the digits in the number \(2^{1000}\).
</p>

<p>
    Since Python supports large integers, we can solve it with this single line:
</p>

<pre><code class="language-python">
print(sum(map(int,str(2**1000))))
</code></pre>

<p>
    In a language without large integers, we have to implement some large
    integer arithmetic. Here is an example that keeps track of the decimal
    digits (least significant first) and doubles it repeatedly.
</p>

<pre><code class="language-python">
P = 1000
number = [1] # start at 1
for _ in range(P):
    carry = 0
    for i in range(len(number)): # multiply by 2
        tmp = 2*number[i] + carry
        number[i] = tmp % 10
        carry = tmp // 10
    if carry > 0: # number gets a digit longer
        number.append(carry)
print(sum(number))
</code></pre>

<details><summary>Answer:</summary>1366</details>

<h2>Problem 17</h2>

<p>
    <b>Problem:</b> Find how many letters are used to write the word form of
    all numbers from 1 to 1000. (Note: the word "and" is used in the hundreds
    to follow British English, for example "three hundred and forty two" or
    "one hundred and fifteen")
</p>

<p>
    We will look at a programming way to do this by writing a function that
    generates the word form of numbers. For small numbers, we use a lookup
    table. Then in the range 20-99, we spit words into 2 parts. For example, 22
    would be "twenty" and "two" so we take the "twenty" from a lookup table for
    the tens place and the ones part with the other lookup table. The ones part
    is nothing when the ones place is 0, so 20 would just by "twenty". For
    hundreds, we need the words for the hundreds digit followed by "and" and
    words for the other 2 digits when it is nonzero, which can be done with the
    work already done. For example, 100 is "one hundred" and 122 is
    "one hundred and twenty two". For simplicity, we handle the special case of
    1000 separately.
</p>

<pre><code class="language-python">
def word_form(n):
    if n &lt; 0:
        return 'negative' + word_form(-n)
    if n &lt; 20: # use lookup table for small numbers
        return [
            'zero', 'one', 'two', 'three', 'four', 'five',
            'six', 'seven', 'eight', 'nine', 'ten',
            'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen',
            'sixteen', 'seventeen', 'eighteen', 'nineteen'
        ][n]
    elif n &lt; 100: # 20-99
        tens,ones = divmod(n,10)
        ret = [
            '', '', 'twenty', 'thirty', 'forty', 'fifty',
            'sixty', 'seventy', 'eighty', 'ninety'
        ][tens]
        if ones != 0:
            ret += word_form(ones)
        return ret
    elif n &lt; 1000: # 100-999
        hundreds,remainder = divmod(n,100)
        ret = word_form(hundreds) + 'hundred'
        if remainder != 0:
            ret += 'and' + word_form(remainder)
        return ret
    else:
        raise Exception('too big')

print(sum(len(word_form(n)) for n in range(1,1000)) + len('onethousand'))
</code></pre>

<p>
    We can also solve this by counting. It is a bit tedious, but doable by hand.
    First, we count the lengths of the numbers 1-19. Below is a table for 1-9
    and 10-19 separately:
</p>

<div style="display:flex;">
<table>
    <tr><th>number</th><th>word form</th><th>length</th></tr>
    <tr><td>1</td><td>one</td><td>3</td></tr>
    <tr><td>2</td><td>two</td><td>3</td></tr>
    <tr><td>3</td><td>three</td><td>5</td></tr>
    <tr><td>4</td><td>four</td><td>4</td></tr>
    <tr><td>5</td><td>five</td><td>4</td></tr>
    <tr><td>6</td><td>six</td><td>3</td></tr>
    <tr><td>7</td><td>seven</td><td>5</td></tr>
    <tr><td>8</td><td>eight</td><td>5</td></tr>
    <tr><td>9</td><td>nine</td><td>4</td></tr>
    <tr><th></th><th>total</th><th>36</th></tr>
</table>
<table>
    <tr><th>number</th><th>word form</th><th>length</th></tr>
    <tr><td>10</td><td>ten</td><td>3</td></tr>
    <tr><td>11</td><td>eleven</td><td>6</td></tr>
    <tr><td>12</td><td>twelve</td><td>6</td></tr>
    <tr><td>13</td><td>thirteen</td><td>8</td></tr>
    <tr><td>14</td><td>fourteen</td><td>8</td></tr>
    <tr><td>15</td><td>fifteen</td><td>7</td></tr>
    <tr><td>16</td><td>sixteen</td><td>7</td></tr>
    <tr><td>17</td><td>seventeen</td><td>9</td></tr>
    <tr><td>18</td><td>eighteen</td><td>8</td></tr>
    <tr><td>19</td><td>nineteen</td><td>8</td></tr>
    <tr><th></th><th>total</th><th>70</th></tr>
</table>
</div>

<p>
    Next, for each range of 10 numbers (20-29, 30-39, ...), we count the tens
    word like "twenty" which is used 10 times and each number 1-9.
</p>

<table>
    <tr><th>tens word</th><th>length</th><th>letters used</th></tr>
    <tr><td>twenty</td><td>6</td><td>10&times;6 + 36 = 96</td></tr>
    <tr><td>thirty</td><td>6</td><td>10&times;6 + 36 = 96</td></tr>
    <tr><td>forty</td><td>5</td><td>10&times;5 + 36 = 86</td></tr>
    <tr><td>fifty</td><td>5</td><td>10&times;5 + 36 = 86</td></tr>
    <tr><td>sixty</td><td>5</td><td>10&times;5 + 36 = 86</td></tr>
    <tr><td>seventy</td><td>7</td><td>10&times;7 + 36 = 106</td></tr>
    <tr><td>eighty</td><td>6</td><td>10&times;6 + 36 = 96</td></tr>
    <tr><td>ninety</td><td>6</td><td>10&times;6 + 36 = 96</td></tr>
    <tr><th></th><th>total</th><th>748</th></tr>
</table>

<p>
    So far we have used 36 + 70 + 748 = 854 letters for numbers 1-99. Now to
    count the ranges 100-199, 200-299, and so on, we have a few parts. First are
    the words like "one hundred". We use each single digit (1-9) word 100 times
    and the word "hundred" 900 times so that is 100&times;36 + 900&times;7 =
    9900. The word "and" is used 99 times in each of the 9 ranges so that is
    another 9&times;99&times;3 = 2673 letters. Finally, in each of the 9 ranges
    we use the words for the numbers 1-99 once each so that is another
    9&times;854 = 7686 letters. Lastly is "one thousand" with 11 letters. By
    adding all these together, we get the answer.
</p>

<details><summary>Answer:</summary>21124</details>

<h2>Problem 18</h2>

<p>
    <b>Problem:</b> Find the maximum total sum following a path from top to
    bottom in the triangle below. (For each step down, there are 2 numbers to
    choose from)
</p>

<p style="font-family:monospace;text-align:center;">
75<br />
95 64<br />
17 47 82<br />
18 35 87 10<br />
20 04 82 47 65<br />
19 01 23 75 03 34<br />
88 02 77 73 07 63 67<br />
99 65 04 28 06 16 70 92<br />
41 41 26 56 83 40 80 70 33<br />
41 48 72 33 47 32 37 16 94 29<br />
53 71 44 65 25 43 91 52 97 51 14<br />
70 11 33 28 77 73 17 78 39 68 17 57<br />
91 71 52 38 17 14 91 43 58 50 27 29 48<br />
63 66 04 68 89 53 67 30 73 16 69 87 40 31<br />
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23<br />
</p>

<p>
    The most obvious solution to this is to try all paths from top to bottom.
    There is a nicer solution, but we will save that for problem 67 which asks
    the same thing on a much larger triangle where brute force is too slow. We
    can do this by recursion. The triangle will be a 2D array with varying row
    lengths. If we are at position \((r,c)\) in the array, then going down a row
    we can move to either \((r+1,c)\) or \((r+1,c+1)\). The following code uses
    a recursive function to try all paths and updates a global variable at the
    end of each path.
</p>

<pre><code class="language-python">
triangle = [
[75],
[95,64],
[17,47,82],
[18,35,87,10],
[20, 4,82,47,65],
[19, 1,23,75, 3,34],
[88, 2,77,73, 7,63,67],
[99,65, 4,28, 6,16,70,92],
[41,41,26,56,83,40,80,70,33],
[41,48,72,33,47,32,37,16,94,29],
[53,71,44,65,25,43,91,52,97,51,14],
[70,11,33,28,77,73,17,78,39,68,17,57],
[91,71,52,38,17,14,91,43,58,50,27,29,48],
[63,66, 4,68,89,53,67,30,73,16,69,87,40,31],
[ 4,62,98,27,23, 9,70,98,73,93,38,53,60, 4,23]]

largestsum = 0
largestpath = []
path = [] # path during recursion (stack)
def recur(r,c):
    global largestsum,largestpath,path,triangle
    path.append(triangle[r][c]) # add to path
    if r == len(triangle)-1: # bottom row
        if sum(path) > largestsum:
            largestsum = sum(path)
            largestpath = path[:]
    else:
        recur(r+1,c)
        recur(r+1,c+1)
    path.pop() # backtrack

recur(0,0)
print(f'the path is {largestpath}')
print(largestsum)
</code></pre>

<details><summary>Answer:</summary>1074<br />The path is:
75, 64, 82, 87, 82, 75, 73, 28, 83, 32, 91, 78, 58, 73, 93</details>

<h2>Problem 19</h2>

<p>
    <b>Problem:</b> Count how many Sundays were on the first of a month during
    the 20th century (1 Jan 1901 to 31 Dec 2000). The following information is
    provided:
</p>

<ul>
    <li>1 Jan 1900 was a Monday</li>
    <li>February has 28 days, except on leap years it has 29</li>
    <li>September, April, June, and November have 30 days</li>
    <li>All other months have 31 days</li>
    <li>Leap years are on any year divisible by 4 except centuries that are not
        divisible by 400</li>
</ul>

<p>
    To solve this, we can begin at 1 Jan 1900 and go up a month at a time. The
    day of the week can be kept track of with an integer modulo 7. The number of
    days to go up at each step is calculated by finding the month length.
</p>

<pre><code class="language-python">
weekday = 1 # 0 = sunday, 1 = monday, ...
count = 0
for y in range(1900,2001):
    months = [31,28,31,30,31,30,31,31,30,31,30,31]
    # set february to 29 days if leap year
    if y % 4 == 0 and not (y % 100 == 0 and y % 400 != 0):
        months[1] = 29
    for m in months:
        if weekday == 0 and 1901 &lt;= y &lt;= 2000:
            count += 1
        weekday = (weekday + m) % 7
print(count)
</code></pre>

<details><summary>Answer:</summary>171</details>

<h2>Problem 20</h2>

<p>
    <b>Problem:</b> Find the sum of digits in the number \(100!\).
</p>

<p>
    This is straight forward in Python with large integer support and using the
    factorial function.
</p>

<pre><code class="language-python">
from math import factorial
print(sum(map(int,str(factorial(100)))))
</code></pre>

<p>
    For a bit more of a challenge, we can represent a decimal number and
    repeatedly multiply it which lets us manage large integer arithmetic code.
    Here is an example where the number is stored as an array of base 10 digits
    starting from least significant. This method works similar to writing out a
    row of the grade school multiplication method.
</p>

<pre><code class="language-python">
num = [1] # start at 1
for n in range(1,1+100): # multiply 1,2,..,100
    carry = 0
    for i in range(len(num)):
        tmp = n*num[i] + carry
        num[i] = tmp % 10
        carry = tmp // 10
    # at the end, we may need to append extra digits for carry
    while carry > 0:
        num.append(carry % 10)
        carry //= 10
print(sum(num))
</code></pre>

<details><summary>Answer:</summary>648</details>

<div style="height:50vh;"></div><!-- allow scrolling a little past end -->

</div>
</body>
</html>
